"use strict";var P=Object.defineProperty;var F=Object.getOwnPropertyDescriptor;var T=Object.getOwnPropertyNames;var q=Object.prototype.hasOwnProperty;var L=(i,e)=>{for(var t in e)P(i,t,{get:e[t],enumerable:!0})},D=(i,e,t,r)=>{if(e&&typeof e=="object"||typeof e=="function")for(let n of T(e))!q.call(i,n)&&n!==t&&P(i,n,{get:()=>e[n],enumerable:!(r=F(e,n))||r.enumerable});return i};var z=i=>D(P({},"__esModule",{value:!0}),i);var _={};L(_,{PrivyConnector:()=>d,PrivyWagmiConnector:()=>x,usePrivyWagmi:()=>R,useSwitchNetwork:()=>S});module.exports=z(_);var h=require("wagmi"),s=require("viem");function W(i){return typeof i=="string"?Number.parseInt(i,i.trim().substring(0,2)==="0x"?16:10):typeof i=="bigint"?Number(i):i}var d=class extends h.Connector{ready=!1;id="privy";name="Privy";activeWallet;provider;logoutFromPrivy;constructor({logout:e,chains:t,activeWallet:r}){super({chains:t,options:void 0}),this.logoutFromPrivy=e,this.activeWallet=r,this.activeWallet&&(this.ready=!0)}getActiveWallet(){return this.activeWallet}async connect({chainId:e}={}){this.emit("message",{type:"connecting"});let t=await this.getAccount();await this.#i();let r=await this.getChainId(),n=this.isChainUnsupported(r);return e&&r!==e&&(r=(await this.switchChain(e)).id,n=this.isChainUnsupported(r)),{account:t,chain:{id:r,unsupported:n}}}async disconnect(){this.provider&&this.#e(this.provider)}async getAccount(){if(!this.activeWallet)throw new h.ConnectorNotFoundError;return(0,s.getAddress)(this.activeWallet.address)}async getChainId(){let t=await(await this.getProvider()).request({method:"eth_chainId"});return W(t)}async getProvider(){if(!this.activeWallet)throw new h.ConnectorNotFoundError;if(!this.provider)try{let e=await this.activeWallet.getEthereumProvider();this.provider=e}catch{throw new h.ConnectorNotFoundError}return this.provider}async getWalletClient({chainId:e}={}){let[t,r]=await Promise.all([this.getProvider(),this.getAccount()]),n=this.chains.find(o=>o.id===e);return(0,s.createWalletClient)({account:r,chain:n,transport:(0,s.custom)(t)})}async isAuthorized(){let[e,t,r]=await Promise.all([this.getProvider(),this.getAccount(),this.activeWallet?.isConnected()]);return!!t&&!!e&&!!r}async switchChain(e){let t=await this.getProvider(),r=(0,s.numberToHex)(e);try{let n=new Promise(o=>{let a=({chain:g})=>{g?.id===e&&(this.off("change",a),o())};this.on("change",a)});return await Promise.all([n,t.request({method:"wallet_switchEthereumChain",params:[{chainId:r.toString()}]})]),this.chains.find(o=>o.id===e)??{id:e,name:`Chain ${r}`,network:`${r}`,nativeCurrency:{name:"Ether",decimals:18,symbol:"ETH"},rpcUrls:{default:{http:[""]},public:{http:[""]}}}}catch(n){let o=this.chains.find(a=>a.id===e);if(!o)throw new h.ChainNotConfiguredError({chainId:e,connectorId:this.id});if(n.code===4902)try{return await t.request({method:"wallet_addEthereumChain",params:[{chainId:r,chainName:o.name,nativeCurrency:o.nativeCurrency,rpcUrls:[o.rpcUrls.public?.http[0]??""],blockExplorerUrls:this.getBlockExplorerUrls(o)}]}),o}catch(a){throw new s.UserRejectedRequestError(a)}throw this.#t(n)?new s.UserRejectedRequestError(n):new s.SwitchChainError(n)}}onAccountsChanged(e){e.length===0?this.emit("disconnect"):this.emit("change",{account:(0,s.getAddress)(this.activeWallet.address)})}onChainChanged=e=>{let t=W(e),r=this.isChainUnsupported(t);this.emit("change",{chain:{id:t,unsupported:r}})};async onDisconnect(e){e?.code===1013&&await this.getProvider()&&await this.getAccount()||(this.ready=!1,this.emit("disconnect"))}#t(e){return/(user rejected)/i.test(e.message)}#r(e){e.on("accountsChanged",this.onAccountsChanged.bind(this)),e.on("chainChanged",this.onChainChanged),e.on("disconnect",this.onDisconnect.bind(this))}#e(e){e.removeListener("accountsChanged",this.onAccountsChanged.bind(this)),e.removeListener("chainChanged",this.onChainChanged),e.removeListener("disconnect",this.onDisconnect.bind(this))}async#i(){let e=this.provider;this.provider=void 0;let t=await this.getProvider();e&&this.#e(e),this.#r(t),this.ready=!0}};var c=require("react"),u=require("wagmi");var v=require("@privy-io/react-auth");var b=require("react");var l=require("wagmi"),p=require("react/jsx-runtime"),E=({children:i})=>{let{connector:e}=A(),{refetch:t}=(0,l.useWalletClient)(),{isConnected:r}=(0,l.useAccount)(),{connect:n,connectors:o,isLoading:a}=(0,l.useConnect)({connector:e});return(0,b.useEffect)(()=>{!r&&!a&&o.length&&e?.activeWallet&&n(),t()},[e?.activeWallet]),(0,p.jsx)(p.Fragment,{children:i})};var C=require("react/jsx-runtime"),I=()=>{throw new Error("You must wrap your application with the `PrivyWagmiConnector` to invoke `setActiveWallet`")},w=(0,c.createContext)({setActiveWallet:I}),A=()=>{let{connector:i}=(0,c.useContext)(w);return{connector:i}},x=({wagmiChainsConfig:i,privyConnectorOverride:e,children:t})=>{let{logout:r}=(0,v.usePrivy)(),{wallets:n}=(0,v.useWallets)(),[o,a]=(0,c.useState)(n[0]),{chains:g,publicClient:N}=i;(0,c.useEffect)(()=>{(o?k(o):void 0)||a(n[0])},[n]);let f=(0,c.useMemo)(()=>e instanceof d?e:new d({logout:r,chains:g,activeWallet:o}),[o,e]),U=(0,c.useMemo)(()=>(0,u.createConfig)({autoConnect:!0,connectors:[f],publicClient:N}),[f]),k=m=>n.find(y=>y.address===m.address&&y.walletClientType===m.walletClientType&&m.connectorType===y.connectorType);return(0,C.jsx)(w.Provider,{value:{connector:f,activeWallet:o,setActiveWallet:a},children:(0,C.jsx)(u.WagmiConfig,{config:U,children:(0,C.jsx)(E,{children:t})})})},R=()=>{let{connector:i,activeWallet:e,setActiveWallet:t}=(0,c.useContext)(w);return{ready:i.ready,wallet:e,setActiveWallet:t}},S=(i={})=>(0,u.useSwitchNetwork)({throwForSwitchChainNotSupported:!0,...i});0&&(module.exports={PrivyConnector,PrivyWagmiConnector,usePrivyWagmi,useSwitchNetwork});
