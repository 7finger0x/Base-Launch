import{Connector as A,ChainNotConfiguredError as x,ConnectorNotFoundError as u}from"wagmi";import{getAddress as C,createWalletClient as R,custom as S,numberToHex as N,UserRejectedRequestError as v,SwitchChainError as U}from"viem";function g(o){return typeof o=="string"?Number.parseInt(o,o.trim().substring(0,2)==="0x"?16:10):typeof o=="bigint"?Number(o):o}var c=class extends A{ready=!1;id="privy";name="Privy";activeWallet;provider;logoutFromPrivy;constructor({logout:e,chains:t,activeWallet:r}){super({chains:t,options:void 0}),this.logoutFromPrivy=e,this.activeWallet=r,this.activeWallet&&(this.ready=!0)}getActiveWallet(){return this.activeWallet}async connect({chainId:e}={}){this.emit("message",{type:"connecting"});let t=await this.getAccount();await this.#i();let r=await this.getChainId(),n=this.isChainUnsupported(r);return e&&r!==e&&(r=(await this.switchChain(e)).id,n=this.isChainUnsupported(r)),{account:t,chain:{id:r,unsupported:n}}}async disconnect(){this.provider&&this.#e(this.provider)}async getAccount(){if(!this.activeWallet)throw new u;return C(this.activeWallet.address)}async getChainId(){let t=await(await this.getProvider()).request({method:"eth_chainId"});return g(t)}async getProvider(){if(!this.activeWallet)throw new u;if(!this.provider)try{let e=await this.activeWallet.getEthereumProvider();this.provider=e}catch{throw new u}return this.provider}async getWalletClient({chainId:e}={}){let[t,r]=await Promise.all([this.getProvider(),this.getAccount()]),n=this.chains.find(i=>i.id===e);return R({account:r,chain:n,transport:S(t)})}async isAuthorized(){let[e,t,r]=await Promise.all([this.getProvider(),this.getAccount(),this.activeWallet?.isConnected()]);return!!t&&!!e&&!!r}async switchChain(e){let t=await this.getProvider(),r=N(e);try{let n=new Promise(i=>{let s=({chain:h})=>{h?.id===e&&(this.off("change",s),i())};this.on("change",s)});return await Promise.all([n,t.request({method:"wallet_switchEthereumChain",params:[{chainId:r.toString()}]})]),this.chains.find(i=>i.id===e)??{id:e,name:`Chain ${r}`,network:`${r}`,nativeCurrency:{name:"Ether",decimals:18,symbol:"ETH"},rpcUrls:{default:{http:[""]},public:{http:[""]}}}}catch(n){let i=this.chains.find(s=>s.id===e);if(!i)throw new x({chainId:e,connectorId:this.id});if(n.code===4902)try{return await t.request({method:"wallet_addEthereumChain",params:[{chainId:r,chainName:i.name,nativeCurrency:i.nativeCurrency,rpcUrls:[i.rpcUrls.public?.http[0]??""],blockExplorerUrls:this.getBlockExplorerUrls(i)}]}),i}catch(s){throw new v(s)}throw this.#t(n)?new v(n):new U(n)}}onAccountsChanged(e){e.length===0?this.emit("disconnect"):this.emit("change",{account:C(this.activeWallet.address)})}onChainChanged=e=>{let t=g(e),r=this.isChainUnsupported(t);this.emit("change",{chain:{id:t,unsupported:r}})};async onDisconnect(e){e?.code===1013&&await this.getProvider()&&await this.getAccount()||(this.ready=!1,this.emit("disconnect"))}#t(e){return/(user rejected)/i.test(e.message)}#r(e){e.on("accountsChanged",this.onAccountsChanged.bind(this)),e.on("chainChanged",this.onChainChanged),e.on("disconnect",this.onDisconnect.bind(this))}#e(e){e.removeListener("accountsChanged",this.onAccountsChanged.bind(this)),e.removeListener("chainChanged",this.onChainChanged),e.removeListener("disconnect",this.onDisconnect.bind(this))}async#i(){let e=this.provider;this.provider=void 0;let t=await this.getProvider();e&&this.#e(e),this.#r(t),this.ready=!0}};import{useEffect as z,createContext as I,useContext as w,useMemo as P,useState as _}from"react";import{createConfig as H,WagmiConfig as $,useSwitchNetwork as j}from"wagmi";import{usePrivy as B,useWallets as M}from"@privy-io/react-auth";import{useEffect as k}from"react";import{useAccount as F,useConnect as T,useWalletClient as q}from"wagmi";import{Fragment as L,jsx as D}from"react/jsx-runtime";var f=({children:o})=>{let{connector:e}=y(),{refetch:t}=q(),{isConnected:r}=F(),{connect:n,connectors:i,isLoading:s}=T({connector:e});return k(()=>{!r&&!s&&i.length&&e?.activeWallet&&n(),t()},[e?.activeWallet]),D(L,{children:o})};import{jsx as m}from"react/jsx-runtime";var Y=()=>{throw new Error("You must wrap your application with the `PrivyWagmiConnector` to invoke `setActiveWallet`")},p=I({setActiveWallet:Y}),y=()=>{let{connector:o}=w(p);return{connector:o}},G=({wagmiChainsConfig:o,privyConnectorOverride:e,children:t})=>{let{logout:r}=B(),{wallets:n}=M(),[i,s]=_(n[0]),{chains:h,publicClient:W}=o;z(()=>{(i?E(i):void 0)||s(n[0])},[n]);let d=P(()=>e instanceof c?e:new c({logout:r,chains:h,activeWallet:i}),[i,e]),b=P(()=>H({autoConnect:!0,connectors:[d],publicClient:W}),[d]),E=a=>n.find(l=>l.address===a.address&&l.walletClientType===a.walletClientType&&a.connectorType===l.connectorType);return m(p.Provider,{value:{connector:d,activeWallet:i,setActiveWallet:s},children:m($,{config:b,children:m(f,{children:t})})})},J=()=>{let{connector:o,activeWallet:e,setActiveWallet:t}=w(p);return{ready:o.ready,wallet:e,setActiveWallet:t}},K=(o={})=>j({throwForSwitchChainNotSupported:!0,...o});export{c as PrivyConnector,G as PrivyWagmiConnector,J as usePrivyWagmi,K as useSwitchNetwork};
